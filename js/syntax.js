// Generated by CoffeeScript 1.12.7

/*
 0000000  000   000  000   000  000000000   0000000   000   000
000        000 000   0000  000     000     000   000   000 000 
0000000     00000    000 0 000     000     000000000    00000  
     000     000     000  0000     000     000   000   000 000 
0000000      000     000   000     000     000   000  000   000
 */

(function() {
  var $, Syntax, _, empty, error, first, last, log, noon, ref, slash, str, valid,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require('../../kxk'), slash = ref.slash, first = ref.first, valid = ref.valid, empty = ref.empty, last = ref.last, noon = ref.noon, str = ref.str, error = ref.error, log = ref.log, $ = ref.$, _ = ref._;

  log = console.log;

  Syntax = (function() {
    function Syntax() {}

    Syntax.exts = [];

    Syntax.lang = null;

    Syntax.init = function() {
      var data, ext, extNames, info, mtchInfo, results, value, valueWords, word, words;
      if (Syntax.lang !== null) {
        return;
      }
      data = noon.load(slash.join(__dirname, '..', 'coffee', 'lang.noon'));
      Syntax.lang = {};
      Syntax.info = {};
      Syntax.mtch = {};
      Syntax.fill = {};
      Syntax.word = {};
      Syntax.turd = {};
      results = [];
      for (extNames in data) {
        valueWords = data[extNames];
        results.push((function() {
          var base, i, len, ref1, results1;
          ref1 = extNames.split(/\s/);
          results1 = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            ext = ref1[i];
            if (indexOf.call(Syntax.exts, ext) < 0) {
              Syntax.exts.push(ext);
            }
            if ((base = Syntax.lang)[ext] == null) {
              base[ext] = {};
            }
            results1.push((function() {
              var base1, results2;
              results2 = [];
              for (value in valueWords) {
                words = valueWords[value];
                if (value === 'comment') {
                  if ((base1 = Syntax.info)[ext] == null) {
                    base1[ext] = {};
                  }
                  results2.push(Syntax.info[ext][value] = words);
                } else if (value === 'match') {
                  results2.push((function() {
                    var base2, base3, base4, base5, base6, name, results3;
                    results3 = [];
                    for (value in words) {
                      mtchInfo = words[value];
                      if (mtchInfo.fill) {
                        if ((base2 = Syntax.fill)[ext] == null) {
                          base2[ext] = {};
                        }
                        mtchInfo.value = value;
                        results3.push(Syntax.fill[ext][mtchInfo.fill] = mtchInfo);
                      } else if (mtchInfo.end) {
                        if ((base3 = Syntax.mtch)[ext] == null) {
                          base3[ext] = {};
                        }
                        if ((base4 = Syntax.mtch[ext])[name = last(mtchInfo.end)] == null) {
                          base4[name] = [];
                        }
                        mtchInfo.value = value;
                        results3.push(Syntax.mtch[ext][last(mtchInfo.end)].push(mtchInfo));
                      } else if (mtchInfo.turd) {
                        if ((base5 = Syntax.turd)[ext] == null) {
                          base5[ext] = {};
                        }
                        mtchInfo.match = value;
                        results3.push(Syntax.turd[ext][value] = mtchInfo);
                      } else {
                        if ((base6 = Syntax.word)[ext] == null) {
                          base6[ext] = {};
                        }
                        mtchInfo.value = value;
                        results3.push(Syntax.word[ext][value] = mtchInfo);
                      }
                    }
                    return results3;
                  })());
                } else {
                  if (!_.isArray(words)) {
                    results2.push((function() {
                      var base2, base3, results3;
                      results3 = [];
                      for (word in words) {
                        info = words[word];
                        if (info) {
                          if ((base2 = Syntax.info)[ext] == null) {
                            base2[ext] = {};
                          }
                          if ((base3 = Syntax.info[ext])[value] == null) {
                            base3[value] = [];
                          }
                          results3.push(Syntax.info[ext][value].push({
                            kind: word[0] === 't' ? 'turd' : 'word',
                            offset: parseInt(word.slice(1)),
                            info: info
                          }));
                        } else {
                          results3.push(Syntax.lang[ext][word] = value);
                        }
                      }
                      return results3;
                    })());
                  } else {
                    results2.push((function() {
                      var j, len1, results3;
                      results3 = [];
                      for (j = 0, len1 = words.length; j < len1; j++) {
                        word = words[j];
                        results3.push(Syntax.lang[ext][word] = value);
                      }
                      return results3;
                    })());
                  }
                }
              }
              return results2;
            })());
          }
          return results1;
        })());
      }
      return results;
    };

    Syntax.ranges = function(text, ext) {
      var char, i, len, obj;
      Syntax.init();
      obj = {
        ext: ext != null ? ext : 'txt',
        rgs: [],
        words: [],
        word: '',
        turd: '',
        last: '',
        index: 0,
        text: text
      };
      switch (obj.ext) {
        case 'cpp':
        case 'hpp':
        case 'c':
        case 'h':
        case 'cc':
        case 'cxx':
        case 'cs':
          obj.cpplang = true;
          obj.cpp = true;
          break;
        case 'coffee':
        case 'js':
        case 'ts':
          obj.jslang = true;
          obj[obj.ext] = true;
          break;
        case 'html':
        case 'htm':
          obj.html = true;
          break;
        case 'yaml':
        case 'yml':
          obj.yaml = true;
          break;
        case 'css':
        case 'styl':
        case 'scss':
        case 'sass':
          obj.csslang = true;
          obj[obj.ext] = true;
          break;
        default:
          obj[obj.ext] = true;
      }
      if (obj.jslang || obj.iss || obj.log || obj.json || obj.yaml) {
        obj.dictlang = true;
      }
      if (obj.csslang || obj.iss || obj.pug) {
        obj.dashlang = true;
      }
      if (obj.cpplang || obj.jslang || obj.log) {
        obj.dotlang = true;
      }
      if (obj.xml || obj.html || obj.plist) {
        obj.xmllang = true;
      }
      for (i = 0, len = text.length; i < len; i++) {
        char = text[i];
        if (obj.char === '\\') {
          if (obj.escp) {
            delete obj.escp;
          } else {
            obj.escp = true;
          }
        } else {
          delete obj.escp;
        }
        obj.char = char;
        if (obj.interpolation && obj.char === '}') {
          Syntax.endWord(obj);
          obj.rgs.push({
            start: obj.index,
            match: obj.char,
            value: obj.interpolation + " punctuation"
          });
          obj.string = {
            start: obj.index + 1,
            value: obj.interpolation,
            match: ''
          };
          obj.index++;
          continue;
        }
        if (obj.string) {
          Syntax.doString(obj);
        } else if (obj.comment) {
          Syntax.doComment(obj);
        } else {
          switch (char) {
            case "'":
            case '"':
            case '`':
              if (!obj.escp && (char !== "'" || obj.jslang || obj.pug)) {
                Syntax.startString(obj);
              } else {
                Syntax.doPunct(obj);
              }
              break;
            case '+':
            case '*':
            case '<':
            case '>':
            case '=':
            case '^':
            case '~':
            case '@':
            case '$':
            case '&':
            case '%':
            case '#':
            case '/':
            case '\\':
            case ':':
            case '.':
            case ';':
            case ',':
            case '!':
            case '?':
            case '|':
            case '{':
            case '}':
            case '(':
            case ')':
            case '[':
            case ']':
              Syntax.doPunct(obj);
              break;
            case '-':
              if (obj.dashlang) {
                Syntax.doWord(obj);
              } else {
                Syntax.doPunct(obj);
              }
              break;
            case ' ':
            case '\t':
              Syntax.endWord(obj);
              break;
            default:
              Syntax.doWord(obj);
          }
          if (char !== ' ' && char !== '\t') {
            Syntax.coffeeCall(obj);
          }
        }
        obj.index++;
      }
      obj.char = null;
      Syntax.endWord(obj);
      Syntax.endLine(obj);
      return obj.rgs;
    };

    Syntax.endWord = function(obj) {
      var char, clss, getMatch, getValue, i, index, j, k, l, lastTurd, lcword, len, match, matchValue, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref3, ref4, ref5, ref6, ref7, ref8, ref9, setClass, setValue, turdInfo, valueInfo, word, wordInfo, wordValue;
      char = (ref1 = obj.char) != null ? ref1 : '';
      obj.turd += char;
      switch (char) {
        case ' ':
        case '\t':
          Syntax.doTurd(obj);
          if ((obj.regexp != null) && !obj.escp) {
            delete obj.regexp;
          }
          if (obj.noon) {
            if (obj.turd.endsWith('  ')) {
              if (((ref2 = first(obj.rgs)) != null ? ref2.start : void 0) > 0) {
                for (index = i = 0, ref3 = obj.rgs.length; 0 <= ref3 ? i < ref3 : i > ref3; index = 0 <= ref3 ? ++i : --i) {
                  Syntax.substitute(obj, -index - 1, ['text'], ['property']);
                  Syntax.substitute(obj, -index - 1, ['punctuation'], ['property punctuation']);
                }
              }
            }
          }
      }
      if (valid(obj.word)) {
        word = obj.word;
        obj.words.push(word);
        obj.word = '';
        getValue = function(back) {
          if (back == null) {
            back = -1;
          }
          return Syntax.getValue(obj, back);
        };
        getMatch = function(back) {
          if (back == null) {
            back = -1;
          }
          return Syntax.getMatch(obj, back);
        };
        setValue = function(back, value) {
          return Syntax.setValue(obj, back, value);
        };
        setClass = function(clss) {
          var ref4;
          if (obj.coffee) {
            if (((ref4 = last(obj.rgs)) != null ? ref4.match : void 0) === '@') {
              if (clss === 'text') {
                clss = 'member';
              }
              last(obj.rgs).value = clss + ' punctuation';
            }
          } else if (obj.js) {
            if (clss === 'keyword function') {
              Syntax.replace(obj, -2, [
                {
                  word: true
                }, {
                  match: '='
                }
              ], [
                {
                  value: 'function'
                }
              ]);
            }
          }
          obj.rgs.push({
            start: obj.index - word.length,
            match: word,
            value: clss
          });
          return null;
        };
        if (valid(obj.fill)) {
          return setClass(obj.fill.value);
        }
        switch (char) {
          case ':':
            if (obj.dictlang) {
              return setClass('dictionary key');
            }
            break;
          case '=':
            if (obj.ini) {
              return setClass('property');
            }
        }
        if (Syntax.turd[obj.ext]) {
          lastTurd = last(obj.last.split(/\s+/));
          if (turdInfo = Syntax.turd[obj.ext][lastTurd]) {
            if (turdInfo.spaced !== true || obj.last[obj.last.length - lastTurd.length - 1] === ' ') {
              if (turdInfo['w-1']) {
                setValue(-turdInfo.match.length - 1, turdInfo['w-1']);
              }
              for (index = j = 0, ref4 = turdInfo.match.length; 0 <= ref4 ? j < ref4 : j > ref4; index = 0 <= ref4 ? ++j : --j) {
                setValue(-index - 1, turdInfo.turd);
              }
              if (turdInfo['w-0']) {
                return setClass(turdInfo['w-0']);
              }
            }
          }
        }
        lcword = word.toLowerCase();
        if (wordInfo = (ref5 = Syntax.word[obj.ext]) != null ? ref5[lcword] : void 0) {
          if (ref6 = obj.last, indexOf.call(Object.keys(wordInfo['t-1']), ref6) >= 0) {
            setValue(-2, wordInfo.value + ' ' + wordInfo['w-1']);
            setValue(-1, wordInfo.value + ' ' + wordInfo['t-1'][obj.last]);
            return setClass(wordInfo.value + ' ' + wordInfo.word);
          }
        }
        if (wordValue = (ref7 = Syntax.lang[obj.ext]) != null ? ref7[lcword] : void 0) {
          if (((ref8 = Syntax.info[obj.ext]) != null ? ref8[wordValue] : void 0) != null) {
            ref9 = Syntax.info[obj.ext][wordValue];
            for (k = 0, len = ref9.length; k < len; k++) {
              valueInfo = ref9[k];
              ref10 = valueInfo.info;
              for (match in ref10) {
                matchValue = ref10[match];
                if (obj.last.trim().endsWith(match)) {
                  for (index = l = 0, ref11 = match.length; 0 <= ref11 ? l < ref11 : l > ref11; index = 0 <= ref11 ? ++l : --l) {
                    setValue(-1 - index, matchValue + ' punctuation');
                  }
                  return setClass(matchValue);
                }
              }
            }
          } else {
            return setClass(wordValue);
          }
        }
        if (obj.coffee) {
          if ((ref12 = getMatch(-1)) === 'class' || ref12 === 'extends') {
            return setClass('class');
          }
          if (((ref13 = getValue(-1)) != null ? ref13.indexOf('punctuation') : void 0) < 0) {
            if (word !== 'else' && word !== 'then' && word !== 'and' && word !== 'or' && word !== 'in') {
              if ((ref14 = last(obj.rgs).value) !== 'keyword' && ref14 !== 'function head' && ref14 !== 'require' && ref14 !== 'number') {
                setValue(-1, 'function call');
              }
            }
          }
        }
        if (/^0x[a-fA-F\d][a-fA-F\d][a-fA-F\d]+$/.test(word)) {
          setValue(-2, 'number hex punctuation');
          setValue(-1, 'number hex punctuation');
          return setClass('number hex');
        }
        if (getMatch(-1) === "#") {
          if (/^[a-fA-F\d]+$/.test(word)) {
            setValue(-1, 'number hex punctuation');
            return setClass('number hex');
          }
        }
        if (obj.noon) {
          if (obj.words.length === 1) {
            if (empty(obj.last)) {
              return setClass('class');
            }
          }
        } else if (obj.sh) {
          if (obj.words.length > 1 && getMatch(-1) === '-' && getValue(-2) === 'argument') {
            setClass(-1, 'argument punctuation');
            return setClass('argument');
          }
        }
        if (obj.cpplang) {
          if (obj.last === '::') {
            if (obj.rgs.length >= 3) {
              setValue(-3, 'namespace');
              setValue(-2, 'punctuation namespace');
              setValue(-1, 'punctuation namespace');
              if (char === '(') {
                return setClass('function call');
              }
              return setClass('property');
            }
          }
          if (/^[\\_A-Z][\\_A-Z0-9]+$/.test(word)) {
            return setClass('macro');
          }
          if (/^[UA][A-Z]\w+$/.test(word)) {
            return setClass('type class');
          } else if (/^[SF][A-Z]\w+$/.test(word)) {
            return setClass('type struct');
          } else if (/^[E][A-Z]\w+$/.test(word)) {
            return setClass('type enum');
          }
          if (indexOf.call(obj.words, 'class') >= 0) {
            return setClass('class');
          }
          if (char === '<') {
            return setClass('type template');
          }
          if (obj.last === '::') {
            if ((ref15 = getValue(-3)) === 'enum' || ref15 === 'class' || ref15 === 'struct') {
              log('really?');
              clss = getValue(-3);
              setValue(-3, getValue(-3) + ' punctuation');
              setValue(-2, getValue(-3) + ' punctuation');
              setValue(-1, getValue(-3) + ' punctuation');
            }
          }
          if (obj.last === '.' && /^\d+f$/.test(word)) {
            if (getValue(-2) === 'number') {
              setValue(-2, 'number float');
              setValue(-1, 'number float punctuation');
              return setClass('number float');
            }
          }
          if (obj.last.endsWith("##")) {
            setValue(-2, 'punctuation operator');
            setValue(-1, 'punctuation operator');
          } else if (obj.last.endsWith('->')) {
            setValue(-3, 'obj');
            setValue(-2, 'property punctuation');
            setValue(-1, 'property punctuation');
            return setClass('property');
          }
          if (first(obj.words).startsWith('U') && ((ref16 = first(obj.rgs)) != null ? ref16.value : void 0) === 'macro') {
            if (word.startsWith('Blueprint')) {
              return setClass('macro punctuation');
            }
            if ((ref17 = word.toLowerCase()) === 'meta' || ref17 === 'displayname' || ref17 === 'category' || ref17 === 'worldcontext' || ref17 === 'editanywhere') {
              return setClass('macro punctuation');
            }
            if ((ref18 = word.toLowerCase()) === 'config' || ref18 === 'transient' || ref18 === 'editdefaultsonly' || ref18 === 'visibleanywhere' || ref18 === 'nontransactional' || ref18 === 'interp' || ref18 === 'globalconfig') {
              return setClass('macro');
            }
          }
        }
        if (/^\d+$/.test(word)) {
          if (obj.last === '.') {
            if (getValue(-4) === 'number float' && getValue(-2) === 'number float') {
              setValue(-4, 'semver');
              setValue(-3, 'semver punctuation');
              setValue(-2, 'semver');
              setValue(-1, 'semver punctuation');
              return setClass('semver');
            }
            if (getValue(-2) === 'number') {
              setValue(-2, 'number float');
              setValue(-1, 'number float punctuation');
              return setClass('number float');
            }
          }
          return setClass('number');
        }
        if (obj.dotlang) {
          if ((ref19 = obj.last) === '.' || ref19 === ':') {
            if ((ref20 = getValue(-2)) === 'text' || ref20 === 'module' || ref20 === 'class' || ref20 === 'member' || ref20 === 'keyword') {
              if (getValue(-2) === 'text') {
                setValue(-2, 'obj');
              }
              setValue(-1, 'property punctuation');
              if (char === '(') {
                return setClass('function call');
              } else {
                return setClass('property');
              }
            }
          }
          if (obj.last.endsWith('.')) {
            if (getValue(-2) === 'property') {
              setValue(-1, 'property punctuation');
              if (char === '(') {
                return setClass('function call');
              } else {
                return setClass('property');
              }
            }
            if (obj.last.length > 1) {
              if ((ref21 = obj.last[obj.last.length - 2]) === ')' || ref21 === ']') {
                setValue(-1, 'property punctuation');
                return setClass('property');
              }
              if (obj.coffee) {
                if (obj.last[obj.last.length - 2] === '?') {
                  if (getValue(-3) === 'text') {
                    setValue(-3, 'obj');
                  }
                  setValue(-2, 'operator punctuation');
                  setValue(-1, 'property punctuation');
                  return setClass('property');
                }
              }
            }
          }
        }
        if (obj.csslang) {
          if (word.endsWith('s')) {
            if (/\d+s/.test(word)) {
              return setClass('number');
            }
          }
          if ((ref22 = word.slice(word.length - 2)) === 'px' || ref22 === 'em' || ref22 === 'ex' || ref22 === 'ch') {
            return setClass('number');
          }
        }
        if (obj.csslang || obj.pug) {
          if (obj.last.endsWith('.')) {
            setValue(-1, 'class punctuation');
            return setClass('class');
          }
          if (obj.last.endsWith("#")) {
            setValue(-1, 'cssid punctuation');
            return setClass('cssid');
          }
        }
        if (obj.cpplang || obj.js) {
          if (char === '(') {
            return setClass('function call');
          }
        }
        return setClass('text');
      }
      return null;
    };

    Syntax.coffeeCall = function(obj) {
      var ref1, ref2, val;
      if (obj.coffee) {
        if (obj.turd === '(') {
          return Syntax.setValue(obj, -2, 'function call');
        } else if (obj.turd.length > 1 && obj.turd[obj.turd.length - 2] === ' ') {
          if (ref1 = last(obj.turd), indexOf.call('@+-\'"([{', ref1) >= 0) {
            if (ref2 = last(obj.turd), indexOf.call('+-', ref2) >= 0) {
              if (obj.text[obj.index + 1] === ' ') {
                return;
              }
            }
            val = Syntax.getValue(obj, -2);
            if (valid(val) && (val !== 'keyword' && val !== 'function head' && val !== 'require')) {
              if (val.indexOf('punctuation') < 0) {
                return Syntax.setValue(obj, -2, 'function call');
              }
            }
          }
        }
      }
    };

    Syntax.doWord = function(obj) {
      if (valid(obj.turd)) {
        Syntax.doTurd(obj);
        obj.last = obj.turd;
        obj.turd = '';
      }
      obj.word += obj.char;
      return null;
    };

    Syntax.doTurd = function(obj) {
      var i, index, ref1, ref2, ref3, results;
      if (empty(obj.fill) && empty(obj.words) && (((ref1 = Syntax.fill[obj.ext]) != null ? ref1[obj.turd] : void 0) != null)) {
        obj.fill = (ref2 = Syntax.fill[obj.ext]) != null ? ref2[obj.turd] : void 0;
        results = [];
        for (index = i = 0, ref3 = obj.turd.length; 0 <= ref3 ? i < ref3 : i > ref3; index = 0 <= ref3 ? ++i : --i) {
          if (obj.fill.turd) {
            results.push(Syntax.setValue(obj, -1 - index, obj.fill.turd));
          } else {
            results.push(Syntax.setValue(obj, -1 - index, obj.fill.value + ' ' + 'punctuation'));
          }
        }
        return results;
      }
    };

    Syntax.doPunct = function(obj) {
      var getValue, i, index, j, len, matchValue, mtch, ref1, ref2, ref3, ref4, ref5, setValue, turd, val, value;
      Syntax.endWord(obj);
      getValue = function(back) {
        if (back == null) {
          back = -1;
        }
        return Syntax.getValue(obj, back);
      };
      setValue = function(back, value) {
        return Syntax.setValue(obj, back, value);
      };
      value = 'punctuation';
      switch (obj.char) {
        case ':':
          if (obj.dictlang && obj.turd.length === 1) {
            if (((ref1 = last(obj.rgs)) != null ? ref1.value : void 0) === 'dictionary key') {
              value = 'dictionary punctuation';
            }
          }
          break;
        case '>':
          if (obj.jslang) {
            ref2 = [['->', ''], ['=>', ' bound']];
            for (i = 0, len = ref2.length; i < len; i++) {
              ref3 = ref2[i], turd = ref3[0], val = ref3[1];
              if (obj.turd.endsWith(turd)) {
                Syntax.substitute(obj, -3, ['dictionary key', 'dictionary punctuation'], ['method', 'method punctuation']);
                Syntax.surround(obj, -1, {
                  start: '(',
                  add: 'argument',
                  end: ')'
                });
                Syntax.replace(obj, -3, [
                  {
                    word: true,
                    ignore: 'argument'
                  }, {
                    match: '='
                  }
                ], [
                  {
                    value: 'function'
                  }
                ]);
                setValue(-1, 'function tail' + val + ' punctuation');
                value = 'function head' + val + ' punctuation';
              }
            }
          } else if (obj.xmllang || obj.md) {
            if (obj.turd.endsWith('/>')) {
              setValue(-1, 'keyword punctuation');
            }
            value = 'keyword punctuation';
          }
          break;
        case '/':
          if (obj.jslang) {
            if (!obj.escp) {
              if (obj.regexp != null) {
                for (index = j = ref4 = obj.rgs.length - 1; ref4 <= 0 ? j <= 0 : j >= 0; index = ref4 <= 0 ? ++j : --j) {
                  if (obj.rgs[index].start < obj.regexp) {
                    break;
                  }
                  obj.rgs[index].value = 'regexp ' + obj.rgs[index].value;
                }
                value = 'regexp punctuation';
              } else {
                obj.regexp = obj.index;
              }
            }
          }
      }
      if (mtch = (ref5 = Syntax.mtch[obj.ext]) != null ? ref5[obj.char] : void 0) {
        if (matchValue = Syntax.doMatch(obj, mtch)) {
          value = matchValue;
        }
      }
      if (obj.fill) {
        value = obj.fill.value + ' ' + value;
      }
      obj.rgs.push({
        start: obj.index,
        match: obj.char,
        value: value
      });
      return Syntax.checkComment(obj);
    };


    /*
     0000000   0000000   00     00  00     00  00000000  000   000  000000000  
    000       000   000  000   000  000   000  000       0000  000     000     
    000       000   000  000000000  000000000  0000000   000 0 000     000     
    000       000   000  000 0 000  000 0 000  000       000  0000     000     
     0000000   0000000   000   000  000   000  00000000  000   000     000
     */

    Syntax.checkComment = function(obj) {
      var comment, ref1;
      if (empty((ref1 = Syntax.info[obj.ext]) != null ? ref1.comment : void 0)) {
        return;
      }
      if (obj.regexp != null) {
        return;
      }
      comment = Syntax.info[obj.ext].comment;
      if (comment.line && obj.turd.endsWith(comment.line) && !obj.turd.endsWith('\\' + comment.line) && empty(obj.words)) {
        Syntax.startComment(obj, comment.line);
      }
      if (comment.tail && obj.turd.endsWith(comment.tail) && !obj.turd.endsWith('\\' + comment.tail)) {
        Syntax.startComment(obj, comment.tail);
      } else if (comment.start && obj.turd.endsWith(comment.start) && !obj.turd.endsWith('\\' + comment.start)) {
        Syntax.startComment(obj, comment.start);
      }
      return null;
    };

    Syntax.startComment = function(obj, start) {
      var i, index, ref1, results;
      obj.comment = {
        start: obj.index + 1,
        match: '',
        value: 'comment'
      };
      results = [];
      for (index = i = 0, ref1 = start.length; 0 <= ref1 ? i < ref1 : i > ref1; index = 0 <= ref1 ? ++i : --i) {
        results.push(Syntax.setValue(obj, -1 - index, 'comment punctuation'));
      }
      return results;
    };

    Syntax.doComment = function(obj) {
      var comment, i, index, ref1;
      comment = Syntax.info[obj.ext].comment;
      if (comment.end && obj.turd.endsWith(comment.end)) {
        obj.rgs.push(obj.comment);
        delete obj.comment;
        for (index = i = 0, ref1 = comment.end.length; 0 <= ref1 ? i < ref1 : i > ref1; index = 0 <= ref1 ? ++i : --i) {
          Syntax.setValue(obj, -1 - index, 'comment punctuation');
        }
      } else {
        Syntax.cont(obj, 'comment');
      }
      return null;
    };


    /*
     0000000  000000000  00000000   000  000   000   0000000   
    000          000     000   000  000  0000  000  000        
    0000000      000     0000000    000  000 0 000  000  0000  
         000     000     000   000  000  000  0000  000   000  
    0000000      000     000   000  000  000   000   0000000
     */

    Syntax.startString = function(obj) {
      var stringType;
      Syntax.endWord(obj);
      stringType = (function() {
        switch (obj.char) {
          case "'":
            return 'string single';
          case '"':
            return 'string double';
          case '`':
            return 'string backtick';
        }
      })();
      if (!stringType) {
        error("no string char '" + obj.char + "'");
        return;
      }
      obj.rgs.push({
        start: obj.index,
        match: obj.char,
        value: stringType + " punctuation"
      });
      obj.string = {
        value: stringType,
        start: obj.index + 1,
        match: ''
      };
      return null;
    };

    Syntax.doString = function(obj) {
      var stringType;
      if (obj.coffee) {
        if (obj.char === '{' && obj.string.value !== 'string single' && obj.string.match.endsWith("#")) {
          obj.interpolation = obj.string.value;
          obj.rgs.push(obj.string);
          obj.rgs.push({
            start: obj.index,
            match: obj.char,
            value: obj.interpolation + " punctuation"
          });
          delete obj.string;
          return;
        }
      }
      stringType = (function() {
        switch (obj.char) {
          case "'":
            return 'string single';
          case '"':
            return 'string double';
          case '`':
            return 'string backtick';
        }
      })();
      if (!obj.escp && obj.string.value === stringType) {
        if (valid(obj.string.match.trim())) {
          obj.rgs.push(obj.string);
        }
        delete obj.string;
        obj.rgs.push({
          start: obj.index,
          match: obj.char,
          value: stringType + " punctuation"
        });
      } else {
        Syntax.cont(obj, 'string');
      }
      return null;
    };

    Syntax.cont = function(obj, key) {
      var strOrCmt;
      strOrCmt = obj[key];
      switch (obj.char) {
        case ' ':
        case '\t':
          if (strOrCmt.match === '') {
            strOrCmt.start += 1;
          } else {
            if (valid(strOrCmt.match)) {
              obj.rgs.push(strOrCmt);
            }
            obj[key] = {
              start: obj.index + 1,
              match: '',
              value: strOrCmt.value
            };
          }
          break;
        default:
          strOrCmt.match += obj.char;
      }
      return null;
    };

    Syntax.endLine = function(obj) {
      if (obj.string) {
        if (obj.jslang || obj.cpplang) {
          obj.rgs.push(obj.string);
        }
      } else if (obj.comment) {
        obj.rgs.push(obj.comment);
      }
      return null;
    };

    Syntax.getMatch = function(obj, back) {
      var ref1, ref2;
      if (back < 0) {
        return (ref1 = obj.rgs[obj.rgs.length + back]) != null ? ref1.match : void 0;
      } else {
        return (ref2 = obj.rgs[back]) != null ? ref2.match : void 0;
      }
    };

    Syntax.getValue = function(obj, back) {
      var ref1, ref2;
      if (back < 0) {
        return (ref1 = obj.rgs[obj.rgs.length + back]) != null ? ref1.value : void 0;
      } else {
        return (ref2 = obj.rgs[back]) != null ? ref2.value : void 0;
      }
    };

    Syntax.setValue = function(obj, back, value) {
      var ref1;
      if (back < 0) {
        back = obj.rgs.length + back;
      }
      if (back < obj.rgs.length && back >= 0) {
        obj.rgs[back].value = value;
        if (obj.coffee && (obj.rgs[back - 1] != null)) {
          if (((ref1 = obj.rgs[back - 1]) != null ? ref1.match : void 0) === '@') {
            return obj.rgs[back - 1].value = value + ' punctuation';
          }
        }
      }
    };

    Syntax.addValue = function(obj, back, value) {
      var i, len, ref1, results, val;
      if (back < 0) {
        back = obj.rgs.length + back;
      }
      if (back < obj.rgs.length && back >= 0) {
        ref1 = value.split(/\s+/);
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          val = ref1[i];
          if (indexOf.call(obj.rgs[back].value.split(/\s+/), val) < 0) {
            results.push(obj.rgs[back].value = val + ' ' + obj.rgs[back].value);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    Syntax.substitute = function(obj, back, oldVals, newVals) {
      var i, index, j, ref1, ref2, val;
      for (index = i = 0, ref1 = oldVals.length; 0 <= ref1 ? i < ref1 : i > ref1; index = 0 <= ref1 ? ++i : --i) {
        val = Syntax.getValue(obj, back + index);
        if (val !== oldVals[index]) {
          break;
        }
      }
      if (index === oldVals.length) {
        for (index = j = 0, ref2 = oldVals.length; 0 <= ref2 ? j < ref2 : j > ref2; index = 0 <= ref2 ? ++j : --j) {
          Syntax.setValue(obj, back + index, newVals[index]);
        }
        return;
      }
      if (obj.rgs.length + back - 1 >= 0) {
        return Syntax.substitute(obj, back - 1, oldVals, newVals);
      }
    };

    Syntax.replace = function(obj, back, oldObjs, newObjs) {
      var advance, backObj, i, index, j, k, key, len, ref1, ref2, ref3, results;
      if (obj.rgs.length + back < 0) {
        return;
      }
      advance = function() {
        if (obj.rgs.length + back - 1 >= 0) {
          return Syntax.replace(obj, back - 1, oldObjs, newObjs);
        }
      };
      for (index = i = 0, ref1 = oldObjs.length; 0 <= ref1 ? i < ref1 : i > ref1; index = 0 <= ref1 ? ++i : --i) {
        backObj = obj.rgs[obj.rgs.length + back + index];
        if (!backObj) {
          log('dafuk?', str(obj));
          log('dafuk?', obj.rgs.length + back + index, obj.rgs.length, back, index);
          return;
        }
        if (oldObjs[index].ignore) {
          if (backObj.value.indexOf(oldObjs[index].ignore) >= 0) {
            return advance();
          }
        }
        ref2 = Object.keys(oldObjs[index]);
        for (j = 0, len = ref2.length; j < len; j++) {
          key = ref2[j];
          switch (key) {
            case 'word':
              if (backObj.value.indexOf('punctuation') >= 0) {
                return advance();
              }
              break;
            case 'ignore':
              break;
            default:
              if (oldObjs[index][key] !== backObj[key]) {
                return advance();
              }
          }
        }
      }
      results = [];
      for (index = k = 0, ref3 = newObjs.length; 0 <= ref3 ? k < ref3 : k > ref3; index = 0 <= ref3 ? ++k : --k) {
        backObj = obj.rgs[obj.rgs.length + back + index];
        results.push((function() {
          var l, len1, ref4, results1;
          ref4 = Object.keys(newObjs[index]);
          results1 = [];
          for (l = 0, len1 = ref4.length; l < len1; l++) {
            key = ref4[l];
            results1.push(backObj[key] = newObjs[index][key]);
          }
          return results1;
        })());
      }
      return results;
    };

    Syntax.doMatch = function(obj, mtchs) {
      var endIndex, endMatches, i, index, j, k, l, len, m, mtch, n, o, ref1, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, startIndex, startLength, startMatches;
      for (i = 0, len = mtchs.length; i < len; i++) {
        mtch = mtchs[i];
        startLength = (ref1 = (ref2 = mtch.start) != null ? ref2.length : void 0) != null ? ref1 : 0;
        if (mtch.single) {
          if (obj.text[obj.index + 1] === mtch.end) {
            continue;
          }
          if (((ref3 = last(obj.rgs)) != null ? ref3.match : void 0) === mtch.end) {
            continue;
          }
        }
        if (obj.rgs.length - mtch.end.length - startLength < 0) {
          continue;
        }
        endMatches = true;
        for (endIndex = j = 1, ref4 = mtch.end.length; 1 <= ref4 ? j < ref4 : j > ref4; endIndex = 1 <= ref4 ? ++j : --j) {
          if (obj.rgs[obj.rgs.length - endIndex].match !== mtch.end[mtch.end.length - endIndex]) {
            endMatches = false;
            break;
          }
        }
        if (!endMatches) {
          continue;
        }
        if (mtch.spaced === false) {
          if (obj.turd.indexOf(' ') >= 0) {
            continue;
          }
        }
        if (mtch.start) {
          for (startIndex = k = ref5 = obj.rgs.length - startLength - mtch.end.length; ref5 <= 0 ? k <= 0 : k >= 0; startIndex = ref5 <= 0 ? ++k : --k) {
            startMatches = true;
            for (index = l = 0, ref6 = startLength; 0 <= ref6 ? l < ref6 : l > ref6; index = 0 <= ref6 ? ++l : --l) {
              if (Syntax.getMatch(obj, startIndex + index) !== mtch.start[index]) {
                startMatches = false;
                break;
              }
            }
            if (startMatches) {
              break;
            }
          }
          if (startIndex >= 0) {
            for (index = m = ref7 = startIndex, ref8 = startIndex + startLength; ref7 <= ref8 ? m < ref8 : m > ref8; index = ref7 <= ref8 ? ++m : --m) {
              Syntax.addValue(obj, index, mtch.value + ' punctuation');
            }
            for (index = n = ref9 = startIndex + startLength, ref10 = obj.rgs.length - mtch.end.length + 1; ref9 <= ref10 ? n < ref10 : n > ref10; index = ref9 <= ref10 ? ++n : --n) {
              Syntax.addValue(obj, index, mtch.value);
            }
            for (index = o = ref11 = obj.rgs.length - mtch.end.length + 1, ref12 = obj.rgs.length; ref11 <= ref12 ? o < ref12 : o > ref12; index = ref11 <= ref12 ? ++o : --o) {
              Syntax.addValue(obj, index, mtch.value + ' punctuation');
            }
            return mtch.value + ' punctuation';
          }
        } else {
          Syntax.addValue(obj, -1, mtch.value);
          index = -2;
          while (Syntax.getMatch(obj, index) === '-') {
            Syntax.setValue(obj, index, mtch.value + ' punctuation');
            Syntax.addValue(obj, index - 1, mtch.value);
            index -= 2;
          }
          return mtch.value + ' punctuation';
        }
      }
      return null;
    };

    Syntax.surround = function(obj, back, range) {
      var addIndex, endIndex, i, j, k, ref1, ref2, ref3, ref4, ref5, ref6, startIndex;
      if (obj.rgs.length - 1 + back <= 1) {
        return;
      }
      for (endIndex = i = ref1 = obj.rgs.length - 1 + back; ref1 <= 0 ? i <= 0 : i >= 0; endIndex = ref1 <= 0 ? ++i : --i) {
        if (endIndex >= obj.rgs.length || endIndex < 0) {
          log('dafuk?', endIndex, obj.rgs.length, back);
          return;
        }
        if (obj.rgs[endIndex] == null) {
          log('dafuk2?', endIndex, obj.rgs.length, back);
          return;
        }
        if (range.end === ((ref2 = obj.rgs[endIndex]) != null ? ref2.match : void 0)) {
          for (startIndex = j = ref3 = endIndex - 1; ref3 <= 0 ? j <= 0 : j >= 0; startIndex = ref3 <= 0 ? ++j : --j) {
            if (range.start === ((ref4 = obj.rgs[startIndex]) != null ? ref4.match : void 0)) {
              for (addIndex = k = ref5 = startIndex + 1, ref6 = endIndex; ref5 <= ref6 ? k < ref6 : k > ref6; addIndex = ref5 <= ref6 ? ++k : --k) {
                obj.rgs[addIndex].value = range.add + ' ' + obj.rgs[addIndex].value;
              }
            }
          }
        }
      }
    };

    return Syntax;

  })();

  module.exports = Syntax;

}).call(this);
